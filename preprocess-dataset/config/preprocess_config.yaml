# Version identifier (e.g., v0, v1, v2)
version: "v0"

# Optional notes (will be saved in metadata.json)
notes: "Version v0 - Preprocessing initial: Transformation des volumes 3D (1042×1042×[50-200]) en patches de 256×256×32. Extraction de 4×4=16 patches par volume. Sélection des 32 meilleures slices par méthode intensity (slices avec intensité maximale). Normalisation z-score (moyenne=0, std=1) appliquée patch par patch. Tous les volumes sont préprocessés sans séparation train/test (les splits sont appliqués lors du chargement des données pour l'entraînement)."

paths:
  dataset_json: "/mnt/pve/ds_shared/dataset_enriched_FINAL.json"
  data_root: "/mnt/pve/ds_shared/data/raw"
  output_dir: "/mnt/pve/ds_shared/data/preprocess"

preprocessing:
  # Target size: H × W × D
  target_height: 256
  target_width: 256
  target_depth: 32
  
  # Patch extraction configuration
  #   - 'max': Extract maximum number of patches without overlap in a regular grid
  #   - 'top_n': Extract N best patches based on average pooling score map
  patch_extraction:
    mode: "top_n"  # 'max' or 'top_n'
    # Parameters for 'top_n' mode (only used if mode == 'top_n')
    n_patches: 16  # Number of patches to extract
    pool_stride: 2  # Stride for average pooling (1, 2, or 3). Higher = faster but lower resolution
  
  # Slice selection configuration
  # Methods:
  #   - 'intensity': Selects slices with highest total intensity (sum of all pixel values)
  #   - 'variance': Selects slices with highest variance (most variation in pixel values)
  #   - 'entropy': Selects slices with highest entropy (most information content)
  #   - 'gradient': Selects slices with highest gradient magnitude (most spatial variation)
  #   - 'intensity_range': Selects slices with most pixels in intensity range [min_intensity, max_intensity]
  slice_selection:
    method: "intensity_range"
    # Parameters for 'intensity_range' method (only used if method == 'intensity_range')
    # Can be a single value (applied to all channels) or a list of values (one per channel)
    # Example: min_intensity: 500 or min_intensity: [500, 400, 300] for 3 channels
    min_intensity: null  # Minimum intensity value (inclusive) - scalar or list
    max_intensity: null  # Maximum intensity value (inclusive) - scalar or list
  
  # Normalization configuration
  normalization:
    # Méthode de normalisation: 'z-score', 'min-max', 'robust', 'percentile'
    # - z-score: (x - mean) / std → moyenne=0, std=1
    # - min-max: (x - min) / (max - min) → plage [0, 1]
    # - robust: (x - median) / IQR → robuste aux outliers
    # - percentile: normalise avec percentiles 1-99
    method: "z-score"
    
    # ============================================================================
    # CLIPPING ET REMAPPING
    # ============================================================================
    # Clipping avec remapping des différentes plages dans des intervalles cibles
    # Plage principale à conserver
    # Can be a single value (applied to all channels) or a list of values (one per channel)
    clip_min: null  # Exemple: 500 ou [500, 400, 300]
    clip_max: null  # Exemple: 1000 ou [1000, 900, 800]
    
    # Redimensionnement des différentes plages dans des intervalles cibles
    # Can be a single [min, max] (applied to all channels) or a list of [min, max] (one per channel)
    scale_below_range: null  # [min, max] pour redimensionner [min_patch, clip_min]
                             # Exemple: [0, 0.1] ou [[0, 0.1], [0, 0.05], [0, 0.15]]
    scale_middle_range: null # [min, max] pour redimensionner [clip_min, clip_max]
                             # Exemple: [0.1, 0.9] ou [[0.1, 0.9], [0.05, 0.95], [0.15, 0.85]]
    scale_above_range: null  # [min, max] pour redimensionner [clip_max, max_patch]
                             # Exemple: [0.9, 1] ou [[0.9, 1], [0.95, 1], [0.85, 1]]

# Output: Each patch is saved as a separate .nii.gz file
# Structure: output/preprocessed_{H}x{W}x{D}_{version}/patches/
# Metadata: patches_info.json contains stack_id, label, position_i, position_j for each patch
# Use train_test_split.json during data loading to filter patches by split
