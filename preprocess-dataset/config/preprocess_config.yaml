# Version identifier (e.g., v0, v1, v2)
version: "v0"

# Optional notes (will be saved in metadata.json)
notes: "Version v0 - Preprocessing initial: Transformation des volumes 3D (1042×1042×[50-200]) en patches de 256×256×32. Extraction de 4×4=16 patches par volume. Sélection des 32 meilleures slices par méthode intensity (slices avec intensité maximale). Normalisation z-score (moyenne=0, std=1) appliquée patch par patch. Tous les volumes sont préprocessés sans séparation train/test (les splits sont appliqués lors du chargement des données pour l'entraînement)."

paths:
  dataset_json: "/mnt/pve/ds_shared/dataset_enriched_FINAL.json"
  data_root: "/mnt/pve/ds_shared/data/raw"
  output_dir: "/mnt/pve/ds_shared/data/preprocess"

preprocessing:
  # Target size: H × W × D
  target_height: 256
  target_width: 256
  target_depth: 32
  
  # Patch extraction configuration
  #   - 'max': Extract maximum number of patches without overlap in a regular grid
  #   - 'top_n': Extract N best patches based on average pooling score map
  patch_extraction:
    mode: "top_n"  # 'max' or 'top_n'
    # Parameters for 'top_n' mode (only used if mode == 'top_n')
    n_patches: 16  # Number of patches to extract
    pool_stride: 2  # Stride for average pooling (1, 2, or 3). Higher = faster but lower resolution
  
  # Slice selection configuration
  # Methods:
  #   - 'intensity': Selects slices with highest total intensity (sum of all pixel values)
  #   - 'variance': Selects slices with highest variance (most variation in pixel values)
  #   - 'entropy': Selects slices with highest entropy (most information content)
  #   - 'gradient': Selects slices with highest gradient magnitude (most spatial variation)
  #   - 'intensity_range': Selects slices with most pixels in intensity range [min_intensity, max_intensity]
  slice_selection:
    method: "intensity_range"
    # Parameters for 'intensity_range' method (only used if method == 'intensity_range')
    # Can be a single value (applied to all channels) or a list of values (one per channel)
    # Example: min_intensity: 500 or min_intensity: [500, 400, 300] for 3 channels
    min_intensity: null  # Minimum intensity value (inclusive) - scalar or list
    max_intensity: null  # Maximum intensity value (inclusive) - scalar or list
  
  # Normalization configuration
  normalization:
    # -------------------------------------------------------------------------
    # Méthodes "classiques" (sans stats externes). clip_min/max et scale_* utilisés si définis.
    # -------------------------------------------------------------------------
    # - z-score: (x - mean) / std → moyenne=0, std=1
    # - min-max: (x - min) / (max - min) → plage [0, 1], min/max sur le volume
    # - robust: (x - median) / IQR → robuste aux outliers
    # - percentile: percentiles 1–99 sur le volume → clip puis min-max [0, 1]
    #
    # -------------------------------------------------------------------------
    # Méthodes "stats-based" (data/). clip_min, clip_max, scale_* sont IGNORÉS.
    # Stats stockées dans data/ ; calculées au 1er run si absent, puis réutilisées.
    # -------------------------------------------------------------------------
    # - intensity_global: min/max GLOBAUX par canal (tous les stacks) → clip + min-max [0, 1]
    #   Fichier: data/global_intensity.json
    # - minmax_p1p99: p1/p99 par canal PAR STACK → clip + min-max [0, 1]
    #   Fichier: data/stack_p1p99.json
    # - minmax_p5p95: p5/p95 par canal PAR STACK → clip + min-max [0, 1]
    #   Fichier: data/stack_p5p95.json
    #
    # data_dir: répertoire des stats. null = défaut <project>/data (créé si besoin).
    #           Ignoré pour z-score, min-max, robust, percentile.
    method: "z-score"
    data_dir: null
    
    # ============================================================================
    # CLIPPING ET REMAPPING (ignorés si method = intensity_global | minmax_p1p99 | minmax_p5p95)
    # ============================================================================
    # Clipping avec remapping des différentes plages dans des intervalles cibles.
    # Plage principale à conserver.
    # Scalar ou liste par canal, ex: 500 ou [500, 400, 300]
    clip_min: null
    clip_max: null
    
    # Redimensionnement des plages. [min, max] ou liste par canal.
    scale_below_range: null   # [min_patch, clip_min] → cible
    scale_middle_range: null  # [clip_min, clip_max] → cible (ex: [0, 1])
    scale_above_range: null   # [clip_max, max_patch] → cible

# Output: Each patch is saved as a separate .nii.gz file
# Structure: output/preprocessed_{H}x{W}x{D}_{version}/patches/
# Metadata: patches_info.json contains stack_id, label, position_i, position_j for each patch
# Use train_test_split.json during data loading to filter patches by split
